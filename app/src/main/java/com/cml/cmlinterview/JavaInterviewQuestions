1.类的加载过程,以Person person = new Person()为例
     找到Person.java加载到内存中
     执行static的代码部分
     为Person分配内存空间
     加载Person中的特有属性并进行默认的初始化
     对Person中的特有属性进行显示初始化
     执行Person中的代码块部分
     执行Person对应的构造器
     将person的对象引用保存到栈空间中

 2.JVM相关知识
    图示:res-->drawable-->pic_jvm.png
    由图可见 JVM 主要包含四个部分:
        类加载器(ClassLoader):在jvm运行或者加载类的时候将类加载到内存区域,详细过程可见res-->drawable-->pic_class_loader.png图示
        内存区 : 分为以下五部分
            方法区(Method Area) : 别名: 非堆(non-heap) 用来存储类的结构信息,例如:常量池,静态变量,构造器...方法区里还包含一个运行时常量池,被所有线程共享
            虚拟机栈(VM Stack) : java栈与线程关联,主要用于存储局部变量,对象的引用....
            本地方法栈(Native Method Stack) : 与java栈差不多,是服务于native方法
            堆(Heap) : 用来存储java对象,也是gc的主要区域,被所有线程共享
            程序计数器(Program Counter Register) : 保存当前线程执行的内存地址.多线程执行中,由于可能发生中断去执行别的线程,所以用来记录当前的执行位置,便于恢复执行
        执行引擎 : 执行字节码文件的代码指令
        本地库接口 : 调用C或者C++方法和返回结果
 3.GC机制
    垃圾回收主要分为两个部分:垃圾收集,垃圾清理
    垃圾收集算法:
        1.引用计数法:对象的引用,每增加一个使用它的地方就++,失效就--.所以为0的时候就代表可以被回收了
        2.可达性算法:从根集(一般包括栈中引用的对象,方法区常量池中引用的对象)开始遍历,如果有对象不可达就代表可以被回收
    垃圾回收算法: 详细图示 res-->drawable-->pic_generational_collection_algorithm.png
        1.标记-清除(Mark-Sweep): 标记所有需要回收的对象,然后统一进行清除(基础算法,效率低,会产生大量的碎片)  详见图示:res-->drawable-->pic_mark_sweep.png
        2.复制(Copying) : 把内存区域分为两份(暂起名1号和2号区域),只用1号,待gc工作的时候,把1号中所有非垃圾对象复制到2号区域并进行整理,然后把1号区域进行清理,以此类推(不会出现碎片问题,但是需要2倍的内存空间) 详见图示:res-->drawable-->pic_copying.png
        3.标记-整理(Mark-Compact) : 该算法结合了标记-清除算法和复制算法两者的优点,具体就是对所有待回收的垃圾对象进行标记,然后把未被标记的对象压缩到堆的另一处区域并进行整理(避免了碎片和需要2倍内存空间的问题) 详见图示:res-->drawable-->pic_mark_compact.png
        4.分代收集算法:其实并没有产生新的算法,只是在不同的时期使用了标记-清除,复制和标记-整理算法,按照对象的生命周期进行划分了三个阶段
            年轻代 : 分为了Enden,Survivor1和Survivor2三个区域,新生对象产生在Enden区域,当Enden区域填满的时候触发gc,
                  将存活下来的对象放到Survivor1或者Survivor2区域中,同时也会检查Survivor中存活的对象进行复制并且总会保证一个空的Survivor区域,
                  当执行n次(根据年龄阙值来定)gc后依然存活的对象会被保存到年老代中
            年老代 : 通常会在此区域被占满的时候触发Full GC,回收整个堆内存
            持久代 : 用于存放静态文件,例如:java类,方法....